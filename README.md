# merger

合并两个或多个记录列表（格式可以各不相同），检查丢失的记录。尤其适合对账单的核对。

在合并，允许指定“必须完全吻合”的字段，以及“允许略有出入”的字段（通常用于时间戳）。

## 算法功能

设想有3个账单，分别是A.csv，B.log，C.json，各自格式不同，顺序不同，且由于系统时间误差，时间戳并不完全一致。

A有3条记录A1，A2，A3；B有1条记录B1，C有2条记录C1，C2。

算法能合并出这样的结果：

from A|from B|from C
-|-|-
A1|-|C2
A2|B1|-
A3|-|-
-|-|C1

即，一共有4个订单，三个来源的账单均未完全覆盖所有订单。

## 使用方法

使用者需要开发的：

- 设计一个对象，包含了所有数据共同的字段。
- 这个对象需要实现`Item`结构。包含3个方法，分别是：
    - `Key() string`，基于对象内容生成的字符串，key不同的对象不会被合并为同一组。
    - `CategoryID() int`，对象来源的编号。例如，如果要合并3个来源的话单，则将来源编号为0、1、2，每个来源生成的对象需要在`CategoryID`方法里返回相应的值。
    - `DifferenceFrom(other Item) float64`，需要对比两个对象，返回一个“差异”，这个差异是偏序的，即如果当前Item比参数other小，则应该返回负数。
- 使用者需要自行开发各个来源的记录列表的解析工具，生成对象，并添加到合并器（`Merger`中）。
- 开始合并时，
- `Merger`会返回一个`ItemGroup`列表，每一个`ItemGroup`都是一个**合并后的组**，里面包含了属于该组的所有`Item`对象构成的列表。列表中的`nil`元素意味着某个来源列表中没有该组的记录。

具体用法参见`merger_test.go`。

## 场景举例

通信增值业务公司A，和通信运营商B达成合作，由B向A提供通信底层服务，每月B将账单发给A。

A需要核对收到的账单和自己的账单，检查是否吻合。

A的账单是csv格式的。

```text
# record-A.csv
C001,13700000001,18500000001,2021-01-14 10:31:35
C002,13800000002,18600000002,2021-01-14 10:40:14
```

B的账单是json格式的（每行一个json），而且没有按照时间排序。

```text
# record-B.json
{"callid":"xxx","calling":"13800000002","called":"18600000002","time":"2021-01-14 10:40:22"}
{"callid":"yyy","calling":"13700000001","called":"18500000001","time":"2021-01-14 10:26:22"}
```

本程序经过对比能发现：

calling|called|A-time|A-other|B-time|B-callid
-|-|-|-|-|-
13700000001|18500000001|-|-|2021-01-14 10:26:22|yyy
13700000001|18500000001|2021-01-14 10:31:35|C001|-|-
13800000002|18600000002|2021-01-14 10:40:14|C002|2021-01-14 10:40:22|xxx

注意呼叫`13800000002=>18600000002`的时间戳并不相同，但足够相近，所以算法能将它们视为同一次呼叫。
